#pragma config(Sensor, in1,    left_sharp,     sensorAnalog)
#pragma config(Sensor, in2,    right_sharp,    sensorAnalog)
#pragma config(Sensor, in3,    front_top_short, sensorAnalog)
#pragma config(Sensor, in4,    back_top,       sensorAnalog)
#pragma config(Sensor, dgtl1,  lf_line_sensor, sensorDigitalIn)
#pragma config(Sensor, dgtl2,  rf_line_sensor, sensorDigitalIn)
#pragma config(Sensor, dgtl3,  lb_line_sensor, sensorDigitalIn)
#pragma config(Sensor, dgtl4,  rb_line_sensor, sensorDigitalIn)
#pragma config(Sensor, dgtl5,  startswitch,    sensorDigitalIn)
#pragma config(Sensor, dgtl6,  stopswitch,     sensorDigitalIn)
#pragma config(Sensor, dgtl7,  ball_collected, sensorDigitalIn)
#pragma config(Sensor, dgtl8,  release_check,  sensorDigitalIn)
#pragma config(Sensor, dgtl9,  compass_w,      sensorDigitalIn)
#pragma config(Sensor, dgtl10, compass_s,      sensorDigitalIn)
#pragma config(Sensor, dgtl11, compass_e,      sensorDigitalIn)
#pragma config(Sensor, dgtl12, compass_n,      sensorDigitalIn)
#pragma config(Motor,  port2,           leftmotor,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           rightmotor,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           collectionmotor, tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port9,           releasemotor,  tmotorVex269_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float left_sensor_raw, right_sensor_raw, left_sensor_dist, right_sensor_dist, back_top_raw, back_top_dist, front_top_short_raw, front_top_short_dist;

int released = 0,ball_stored = 0,ball_found = 0,front_line_detected = 0, seq_start = 0, deposit_counter = 0;
int rf,lf,rb,lb;
int search_thresh = 60;

float ashort =  7675.43251, bshort = -30.2142744, cshort = 0.1087;
float along = 23018.2636, blong = -46.4281248, clong = -3.36615819;

int defaultSpeed = 30, rotateSpeed = 40;

// unsigned long previoustime, currenttime;

bool robot_aligned = false;

//Compass
char* global_orientation;
char* orientation_check();
char* orientation;

void goForward(int speed)
{
	motor[leftmotor] = speed;
	motor[rightmotor] = speed;
}

void goReverse(int speed)
{
	motor[leftmotor] = -speed;
	motor[rightmotor] = -speed;
}

void stopMotor()
{
	motor[leftmotor] = 0;
	motor[rightmotor] = 0;
	wait1Msec(100);
}

void rotateRight(int speed)
{
	motor[leftmotor] = speed;
	motor[rightmotor] = -speed;
}

void rotateLeft(int speed)
{
	motor[leftmotor] = -speed;
	motor[rightmotor] = speed;
}

// sensor code
task initialize_sensors()
{
	while(true)
	{
		left_sensor_raw = SensorValue[left_sharp];
		if (left_sensor_raw < 300)
			left_sensor_raw = 300;
		right_sensor_raw = SensorValue[right_sharp];
		if (right_sensor_raw < 300)
			right_sensor_raw = 300;
		back_top_raw = SensorValue[back_top];
		if (back_top_raw < 300)
			back_top_raw = 300;
		front_top_short_raw = SensorValue[front_top_short];
		if (front_top_short_raw < 250)
			front_top_short_raw = 250;
		lb = SensorValue[lb_line_sensor];
		rb = SensorValue[rb_line_sensor];
		lf = SensorValue[lf_line_sensor];
		rf = SensorValue[rf_line_sensor];
		wait1Msec(10);
	}
}

float distance_equation(float a, float b, float c, float x)
{
	float dist;
	dist = a/((b+x)+c);
	return dist;
}

task checkDist()
{
	while(true)
	{
		if (distance_equation(along, blong, clong, left_sensor_raw) < 0)
			left_sensor_dist = 100;
		else if (distance_equation(along, blong, clong, left_sensor_raw) > 0)
			left_sensor_dist = distance_equation(along, blong, clong, left_sensor_raw);

		if (distance_equation(along, blong, clong, right_sensor_raw) < 0)
			right_sensor_dist = 100;
		else if (distance_equation(along, blong, clong, right_sensor_raw) > 0)
			right_sensor_dist = distance_equation(along, blong, clong, right_sensor_raw);

		if (distance_equation(along, blong, clong, back_top_raw) < 0)
			back_top_dist = 100;
		else if (distance_equation(along, blong, clong, back_top_raw) > 0)
			back_top_dist = distance_equation(along, blong, clong, back_top_raw);

		if (distance_equation(ashort, bshort, cshort, front_top_short_raw) < 0)
			front_top_short_dist = 35;
		else if (distance_equation(ashort, bshort, cshort, front_top_short_raw) > 0)
			front_top_short_dist = distance_equation(ashort, bshort, cshort, front_top_short_raw);

		wait1Msec(10);
	}
}

char* orientation_check()
{
	int temp = 8*SensorValue(compass_w)+4*SensorValue(compass_s)+2*SensorValue(compass_e)+SensorValue(compass_n);
	switch(temp) {
	case 14:
		global_orientation = "N";
		break;
	case 12:
		global_orientation = "NE";
		break;
	case 13:
		global_orientation = "E";
		break;
	case 9:
		global_orientation = "SE";
		break;
	case 11:
		global_orientation = "S";
		break;
	case 3:
		global_orientation = "SW";
		break;
	case 7:
		global_orientation = "W";
		break;
	case 6:
		global_orientation = "NW";
		break;
	}
	return global_orientation;
}

task current_orientation()
{
	while(true)
	{
		orientation = orientation_check();
		wait1Msec(10);
	}
}

task realignment()
{
	robot_aligned = false;
	while(!robot_aligned)
	{
		if (orientation == "S")
		{
			rotateLeft(rotateSpeed);
			wait1Msec(300);
			stopMotor();
			wait1Msec(300);
		}

		if (orientation == "N" || orientation == "NW" || orientation == "W" || orientation == "SW")
		{
			rotateLeft(rotateSpeed);
			waitUntil(orientation == "S");
			rotateLeft(rotateSpeed);
			wait1Msec(100);
			stopMotor();
			robot_aligned = true;
		}
		if (orientation == "NE" || orientation == "E" || orientation == "SE")
		{
			rotateRight(rotateSpeed);
			waitUntil(orientation == "S");
			rotateRight(rotateSpeed);
			wait1Msec(100);
			stopMotor();
			robot_aligned = true;
		}
	}
}

int check_ball()
{
	int check = 0;
	//If on left side
	if (left_sensor_dist<search_thresh)
	{
		for (int i=0;i<20;i++)
		{
			//If ball
			if (right_sensor_dist<search_thresh && left_sensor_dist>search_thresh)
			{
				rotateRight(rotateSpeed);
				wait1Msec(300);
				stopMotor();
				check = 1;
				break;
			}
			else
			{
				rotateLeft(rotateSpeed);
				wait1Msec(30);
			}
		}
	}
	//If on right side
	if (right_sensor_dist<search_thresh && check == 0)
	{
		for (int i=0;i<20;i++)
		{
			//if ball
			if (left_sensor_dist<search_thresh && right_sensor_dist>search_thresh)
			{
				rotateLeft(rotateSpeed);
				wait1Msec(300);
				stopMotor();
				check = 1;
				break;
			}
			else
			{
				rotateRight(rotateSpeed);
				wait1Msec(30);
			}
		}
	}
	return check;
}

task search_ball()
{
	ball_found = 0;
	while(ball_found == 0)
	{
		wait1Msec(50);
		//Rotate Left
		if (ball_found == 0)
		{
			for (int i=0; i<20; i++)
			{
				if ((left_sensor_dist<search_thresh && right_sensor_dist>search_thresh) || (left_sensor_dist>search_thresh && right_sensor_dist<search_thresh))
				{
					stopMotor();
					ball_found = check_ball();
					break;
				}
				else
				{
					rotateLeft(rotateSpeed);
					wait1Msec(30);
				}
			}
		}
		if (ball_found == 1)
			break;
		//Rotate right
		if (ball_found == 0)
		{
			for (int i=0; i<40; i++)
			{
				if ((left_sensor_dist<search_thresh && right_sensor_dist>search_thresh) || (left_sensor_dist>search_thresh && right_sensor_dist<search_thresh))
				{
					stopMotor();
					ball_found = check_ball();
					break;
				}
				else
				{
					rotateRight(rotateSpeed);
					wait1Msec(30);
				}
			}
		}
		if (ball_found == 1)
			break;
		//Straighten up Go Forward while checking for one second max
		if (ball_found == 0)
		{
			for (int i = 0; i< 15; i++)
			{
				rotateLeft(rotateSpeed);
				wait1Msec(30);
			}
			goForward(defaultSpeed);
			wait1Msec(1000);
		}
		stopMotor();
	}
}

task collect_ball()
{
	ball_stored = 0;
	goForward(defaultSpeed);
	while (true)
	{
		if (SensorValue[ball_collected]==1)
		{
			motor[collectionmotor] = 127;
			if ((left_sensor_dist < 30 && right_sensor_dist < 30) && front_top_short_dist > 30 && orientation == "N") // front wall detected
			{
				goReverse(defaultSpeed);
				wait1Msec(300);
				startTask(realignment);
				waitUntil(robot_aligned);
				stopTask(realignment);
				goForward(defaultSpeed); // maybe change to exit loop
			}
			if((left_sensor_dist < 30 || right_sensor_dist < 30) && front_top_short_dist < 30) // obstacle detected
			{
				stopMotor();
				motor[collectionmotor] = 0;
				waitUntil(front_top_short_dist > 30);
				motor[collectionmotor] = 127;
				goForward(defaultSpeed);
			}
		}
		else if (SensorValue[ball_collected]==0)
		{
			stopMotor();
			motor[collectionmotor] = -127;
			wait1Msec(1000);
			motor[collectionmotor] = 0;
			ball_stored = 1;
			break;
		}
	}
}

task deposit_ball()
{
	motor[collectionmotor] = 0;
	released = 0;
	stopMotor();
	startTask(realignment);
	wait1Msec(300);
	waitUntil(robot_aligned == 1);
	while(true)
	{
		while (back_top_dist < 25)
		{
			stopMotor(); // can add in avoidance algorithm inside
		}
		while (back_top_dist > 25)
		{
			if (lb == 1 && rb ==1)
			{
				goReverse(60);
			}
			if (lb == 0 && rb == 1)
			{
				while(rb == 1 && back_top_dist > 25)
				{
					goReverse(defaultSpeed);
					wait1Msec(500);
					if (rb == 0)
						break;
					goForward(60);
					wait1Msec(1000);
					stopMotor();
					startTask(realignment);
					wait1Msec(50);
					waitUntil(robot_aligned);
					stopTask(realignment);
					deposit_counter++;
					break;
				}
			}
			if (lb == 1 && rb == 0)
			{
				while(lb == 1 && back_top_dist > 25)
				{
					goReverse(defaultSpeed);
					wait1Msec(500);
					if (lb == 0)
						break;
					goForward(60);
					wait1Msec(1000);
					stopMotor();
					startTask(realignment);
					wait1Msec(50);
					waitUntil(robot_aligned);
					stopTask(realignment);
					deposit_counter++;
					break;
				}
			}
			if ((lb == 0 && rb == 0) || (orientation == "S" && deposit_counter == 2))
			{
				stopMotor();
				wait1Msec(100);
				goReverse(60);
				wait1Msec(2000);
				if (SensorValue[ball_collected] == 0 && released == 0)
				{
					motor[releasemotor] = -50;
					wait1Msec(300);
					while (SensorValue[release_check] == 1)
					{
						motor[releasemotor] = 30;
					}
					motor[releasemotor] = 0;
					released = 1;
					deposit_counter = 0;
				}
				if (SensorValue[ball_collected] == 0 && released == 1)
					released = 0;
			}
		}
	}
}

task check_line()
{
	while (true)
	{
		//Both Front Line Sensors Detect
		if (lf==0 && rf==0)
		{
			wait1Msec(50);
			if (lf==0 && rf==0)
			{
				stopTask(search_ball);
				stopTask(collect_ball);
				goReverse(defaultSpeed);
				wait1Msec(500);
				rotateLeft(rotateSpeed);
				wait1Msec(1000);
				stopMotor();
				front_line_detected = 1;
			}
		}
		//Left Front Line Sensor Detect
		else if (lf==0 && rf==1)
		{
			wait1Msec(50);
			if (lf==0 && rf==1)
			{
				stopTask(search_ball);
				stopTask(collect_ball);
				goReverse(defaultSpeed);
				wait1Msec(500);
				rotateRight(rotateSpeed);
				wait1Msec(1200);
				stopMotor();
				front_line_detected = 1;
			}
		}
		//Right Front Line Sensor Detect
		else if (lf==1 && rf==0)
		{
			wait1Msec(50);
			if (lf==1 && rf==0)
			{
				stopTask(search_ball);
				stopTask(collect_ball);
				goReverse(defaultSpeed);
				wait1Msec(500);
				rotateLeft(rotateSpeed);
				wait1Msec(1200);
				stopMotor();
				front_line_detected = 1;
			}
		}
	}
}

task main()
{
	//Readies Release Motor
	while(SensorValue(release_check) == 1)
	{
		motor[releasemotor] = 30;
	}
	motor[releasemotor] = 0;
	startTask(checkDist);
	startTask(current_orientation);
	startTask(initialize_sensors);
	waitUntil(SensorValue(ball_collected)==0);
	while (true)
	{
		if (seq_start == 0)
		{
			seq_start = 1;
			goForward(127);
			wait1Msec(1400);
			stopMotor();
		}
		front_line_detected = 0;
		startTask(check_line);
		//Skips searching & collecting ball if ball is already in storage
		if (SensorValue[ball_collected]==1)
		{
			startTask(search_ball);
			waitUntil(ball_found == 1 || front_line_detected == 1 || SensorValue[ball_collected]==0);
			//If ball suddenly spawns on limit switch :D
			if (front_line_detected == 1 || SensorValue[ball_collected]==0)
				continue;
			stopTask(search_ball);
			startTask(collect_ball);
			waitUntil(ball_stored == 1 || front_line_detected == 1);
			if (front_line_detected == 1)
			{
				stopTask(collect_ball);
				motor[collectionmotor] = 0;
				continue;
			}
		}
		stopTask(collect_ball);
		stopTask(check_line);
		startTask(deposit_ball);
		waitUntil(released == 1);
		stopTask(deposit_ball);
		if (released == 1)
		{
			released = 0;
			ball_stored = 0;
			ball_found = 0;
			robot_aligned = false;
			seq_start = 0;
		}
	}
}
